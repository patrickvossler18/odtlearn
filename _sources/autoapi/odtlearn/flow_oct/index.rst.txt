:py:mod:`odtlearn.flow_oct`
===========================

.. py:module:: odtlearn.flow_oct


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   odtlearn.flow_oct.FlowOCT
   odtlearn.flow_oct.BendersOCT




.. py:class:: FlowOCT(_lambda=0, obj_mode='acc', depth=1, time_limit=60, num_threads=None, verbose=False)


   Bases: :py:obj:`odtlearn.flow_oct_ss.FlowOCTSingleSink`

   
   Helper class that provides a standard way to create an ABC using
   inheritance.
















   ..
       !! processed by numpydoc !!
   .. py:method:: fit(X, y)


   .. py:method:: predict(X)

      
      Classify test points using the StrongTree classifier


      :Parameters:

          **X** : array-like, shape (n_samples, n_features)
              The input samples.

      :Returns:

          **y** : ndarray, shape (n_samples,)
              The label for each sample is the label of the closest sample
              seen during fit.













      ..
          !! processed by numpydoc !!


.. py:class:: BendersOCT(_lambda=0, obj_mode='acc', depth=1, time_limit=60, num_threads=None, verbose=False)


   Bases: :py:obj:`odtlearn.flow_oct_ss.FlowOCTSingleSink`

   
   Helper class that provides a standard way to create an ABC using
   inheritance.
















   ..
       !! processed by numpydoc !!
   .. py:attribute:: LazyConstraints
      :value: 1

      
      The following variables are used for the Benders problem to keep track
      of the times we call the callback.

      - counter_integer tracks number of times we call the callback from an
      integer node in the branch-&-bound tree
          - time_integer tracks the associated time spent in the
          callback for these calls
      - counter_general tracks number of times we call the callback from
      a non-integer node in the branch-&-bound tree
          - time_general tracks the associated time spent in the callback for
          these calls

      the ones ending with success are related to success calls.
      By success we mean ending up adding a lazy constraint
      to the model















      ..
          !! processed by numpydoc !!

   .. py:method:: fit(X, y)


   .. py:method:: predict(X)

      
      Classify test points using the Benders' Formulation Classifier


      :Parameters:

          **X** : array-like, shape (n_samples, n_features)
              The input samples.

      :Returns:

          **y** : ndarray, shape (n_samples,)
              The label for each sample is the label of the closest sample
              seen during fit.













      ..
          !! processed by numpydoc !!


